// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: sub_command.sql

package db

import (
	"context"
	"time"
)

const createSubCommand = `-- name: CreateSubCommand :one
INSERT INTO sub_commands (
    request_id,
    command,
    command_output,
    command_status,
    execution_order
) VALUES (
    ?, ?, ?, ?, ?
) RETURNING id, request_id, command, command_output, command_status, execution_order, created_at
`

type CreateSubCommandParams struct {
	RequestID      int64  `json:"request_id"`
	Command        string `json:"command"`
	CommandOutput  string `json:"command_output"`
	CommandStatus  string `json:"command_status"`
	ExecutionOrder int64  `json:"execution_order"`
}

func (q *Queries) CreateSubCommand(ctx context.Context, arg CreateSubCommandParams) (SubCommand, error) {
	row := q.db.QueryRowContext(ctx, createSubCommand,
		arg.RequestID,
		arg.Command,
		arg.CommandOutput,
		arg.CommandStatus,
		arg.ExecutionOrder,
	)
	var i SubCommand
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.Command,
		&i.CommandOutput,
		&i.CommandStatus,
		&i.ExecutionOrder,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSubCommand = `-- name: DeleteSubCommand :exec
DELETE FROM sub_commands
WHERE id = ?
`

func (q *Queries) DeleteSubCommand(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSubCommand, id)
	return err
}

const getSubCommand = `-- name: GetSubCommand :one
SELECT id, request_id, command, command_output, command_status, execution_order, created_at FROM sub_commands
WHERE id = ? LIMIT 1
`

func (q *Queries) GetSubCommand(ctx context.Context, id int64) (SubCommand, error) {
	row := q.db.QueryRowContext(ctx, getSubCommand, id)
	var i SubCommand
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.Command,
		&i.CommandOutput,
		&i.CommandStatus,
		&i.ExecutionOrder,
		&i.CreatedAt,
	)
	return i, err
}

const getSubCommandsByStatus = `-- name: GetSubCommandsByStatus :many
SELECT id, request_id, command, command_output, command_status, execution_order, created_at FROM sub_commands
WHERE command_status = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetSubCommandsByStatusParams struct {
	CommandStatus string `json:"command_status"`
	Limit         int64  `json:"limit"`
	Offset        int64  `json:"offset"`
}

func (q *Queries) GetSubCommandsByStatus(ctx context.Context, arg GetSubCommandsByStatusParams) ([]SubCommand, error) {
	rows, err := q.db.QueryContext(ctx, getSubCommandsByStatus, arg.CommandStatus, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SubCommand{}
	for rows.Next() {
		var i SubCommand
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.Command,
			&i.CommandOutput,
			&i.CommandStatus,
			&i.ExecutionOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubCommandsWithRequest = `-- name: GetSubCommandsWithRequest :many
SELECT sc.id, sc.request_id, sc.command, sc.command_output, sc.command_status, sc.execution_order, sc.created_at, cr.input_content, cr.command_type
FROM sub_commands sc
JOIN command_requests cr ON sc.request_id = cr.id
WHERE sc.request_id = ?
ORDER BY sc.execution_order ASC
`

type GetSubCommandsWithRequestRow struct {
	ID             int64     `json:"id"`
	RequestID      int64     `json:"request_id"`
	Command        string    `json:"command"`
	CommandOutput  string    `json:"command_output"`
	CommandStatus  string    `json:"command_status"`
	ExecutionOrder int64     `json:"execution_order"`
	CreatedAt      time.Time `json:"created_at"`
	InputContent   string    `json:"input_content"`
	CommandType    string    `json:"command_type"`
}

func (q *Queries) GetSubCommandsWithRequest(ctx context.Context, requestID int64) ([]GetSubCommandsWithRequestRow, error) {
	rows, err := q.db.QueryContext(ctx, getSubCommandsWithRequest, requestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSubCommandsWithRequestRow{}
	for rows.Next() {
		var i GetSubCommandsWithRequestRow
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.Command,
			&i.CommandOutput,
			&i.CommandStatus,
			&i.ExecutionOrder,
			&i.CreatedAt,
			&i.InputContent,
			&i.CommandType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubCommands = `-- name: ListSubCommands :many
SELECT id, request_id, command, command_output, command_status, execution_order, created_at FROM sub_commands
WHERE request_id = ?
ORDER BY execution_order ASC
`

func (q *Queries) ListSubCommands(ctx context.Context, requestID int64) ([]SubCommand, error) {
	rows, err := q.db.QueryContext(ctx, listSubCommands, requestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SubCommand{}
	for rows.Next() {
		var i SubCommand
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.Command,
			&i.CommandOutput,
			&i.CommandStatus,
			&i.ExecutionOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubCommandOutput = `-- name: UpdateSubCommandOutput :one
UPDATE sub_commands
SET command_output = ?
WHERE id = ?
RETURNING id, request_id, command, command_output, command_status, execution_order, created_at
`

type UpdateSubCommandOutputParams struct {
	CommandOutput string `json:"command_output"`
	ID            int64  `json:"id"`
}

func (q *Queries) UpdateSubCommandOutput(ctx context.Context, arg UpdateSubCommandOutputParams) (SubCommand, error) {
	row := q.db.QueryRowContext(ctx, updateSubCommandOutput, arg.CommandOutput, arg.ID)
	var i SubCommand
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.Command,
		&i.CommandOutput,
		&i.CommandStatus,
		&i.ExecutionOrder,
		&i.CreatedAt,
	)
	return i, err
}

const updateSubCommandStatus = `-- name: UpdateSubCommandStatus :one
UPDATE sub_commands
SET command_status = ?,
    command_output = ?
WHERE id = ?
RETURNING id, request_id, command, command_output, command_status, execution_order, created_at
`

type UpdateSubCommandStatusParams struct {
	CommandStatus string `json:"command_status"`
	CommandOutput string `json:"command_output"`
	ID            int64  `json:"id"`
}

func (q *Queries) UpdateSubCommandStatus(ctx context.Context, arg UpdateSubCommandStatusParams) (SubCommand, error) {
	row := q.db.QueryRowContext(ctx, updateSubCommandStatus, arg.CommandStatus, arg.CommandOutput, arg.ID)
	var i SubCommand
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.Command,
		&i.CommandOutput,
		&i.CommandStatus,
		&i.ExecutionOrder,
		&i.CreatedAt,
	)
	return i, err
}
